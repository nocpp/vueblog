---
title: 谷歌真题
date: '2021-11-17'
sidebar: 'auto'
categories:
 - 数据结构
tags:
 - 谷歌真题
publish: true
---

> 此章题目类型是看起来和代码没什么关系，题目文字多，看了一遍不知道题目在讲什么的题。而我们需要的是将题目翻译成代码形式，然后就可以用熟悉的模型去解决此类问题。总结，这种题目考察的是抽象能力，把实际问题抽象为模型。

## 岛屿数量问题
> 题目描述：给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

:::tip
示例 1:

输入:  
11110  
11010  
11000  
00000  
输出: 1

示例 2:

输入:  
11000
11000
00100
00011  
输出: 3
:::

> 思路分析，看了几遍题目，理解了二维网格就是一个二维数组，里面元素就是0和1，但是岛屿的概念一直没读懂，看了分析才明白，岛屿就是连着的1组成的陆地，在示例1中所有的1都连在一起的，所以只有1个岛屿。示例2中，左上角4个1，中间一个1，右下两个1分别组成3块陆地。

> 所以此题可以转化为输入一个n*m的二维数组，数组元素由0，1组成，求连着的1有几块儿
```js
var numIslands = function(grid) {
    let moveX = [0, 1, 0, -1], moveY = [1, 0, -1, 0];//通过这两个数组就可以找到一个元素的上下左右元素

    if (!grid || grid.length === 0 || grid[0].length === 0) {//过滤边界条件
        return 0;
    }

    let row = grid.length, column = grid[0].length;

    let count = 0;//定义个数

    for (let i = 0; i < row; i++) {//遍历二维数组
        for (let j = 0; j < column; j++) {
            if (grid[i][j] === '1') {
                dfs(grid, i, j);
                count++;
            }
        }
    }

    return count;
	
	//把所有相连的为1的元素设置为0
    function dfs(grid, i, j) {
		//注意条件是i >= row而不是i > row, 相等也不行
        if (i < 0 || i >= row || j < 0 || j >= column || grid[i][j] === '0') {
            return;
        }

        grid[i][j] = '0';

        for (let k = 0; k < 4; k++) {
            dfs(grid, moveX[k] + i, moveY[k] + j);
        }
    }
};
```