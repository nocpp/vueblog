---
title: 微软真题
date: '2021-11-14'
sidebar: 'auto'
categories:
 - 数据结构
tags:
 - 微软真题
publish: true
---

## 最长回文子串
> 题目描述：给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。
:::tip
示例 1：

输入: "babad"  
输出: "bab"  
注意: "aba" 也是一个有效答案。  

示例 2：  

输入: "cbbd"  
输出: "bb"  
:::

### 思路1，使用暴力循环法
1. 遍历找到所有子串
2. 判断每个子串是否是回文字符串
3. 如果字串是回文子串，则与最大的子串进行比较，如果更大则更新最大子串

> 暴力法会导致超时，时间复杂度为O(n^3)

### 思路2，动态规划法
当遇见最值问题，可以考虑动态规划法。求子串需要用到两个指针i, j，然后使用双层数组记录子串是否回文串，d[i][j] = 1时表示是回文子串。
由题可知，d[i][i]肯定等于1，然后d[i][i+1]的状态 看d[i]和d[i+1]是否相等，相等也是1，然后就是根据状态方程来推导

> 状态转移方程
```js
    if (s[i] === s[j]) {
        d[i][j] = d[i + 1][j - 1];//由此可知，d[i][j]状态还由其子串决定
    } else {
        d[i][j] = 0;
    }
```

```js
/**
 * @param {string} s
 * @return {string}
 */
var longestPalindrome = function(s) {
    let st = 0, ed = 0;//初始化最大子串开始和结束索引
    let d = [];//存放子串是否回文的状态
    
    let len = s.length;
    
    for (let i = 0; i < len; i++) {
        d[i] = [];
        d[i][i] = 1;//初始化单个字符串为回文
    }
    
    for (let i = 0; i < len - 1; i++) {
        if (s[i] === s[i + 1]) {//判断长度为2的子串的回文情况
            d[i][i + 1] = 1;
            st = i;
            ed = i + 1;
        }
    }
    
    for (let n = 3; n <= len; n++) {//判断子串长度为3以上的情况，n <= len因为当len等于3时，也要遍历
        for (let i = 0; i < len - n + 1; i++) {//移动子串，就像游标卡尺移动一样，子串长度由n决定
            let j = n + i - 1;//j为长度为n的子串末端索引
            
            if (d[i + 1][j - 1]) {//状态转移方程，判断出d[i][j]的回文状态
                if (s[i] === s[j]) {
                    d[i][j] = 1;
                    st = i;
                    ed = j;
                }
            }
        }
    }
    
    return s.slice(st, ed + 1);//返回最长回文子串
};
```