---
title: 计算机网络概述
date: '2022-09-14'
sidebar: 'auto'
categories:
 - 计算机基础
tags:
 - 计算机系统
publish: true
---
## 计算机系统
由硬件系统和软件系统组成

## 基本硬件系统，五部分
- 运算器，CPU组成
- 控制器，CPU组成
- 存储器
- 输入设备
- 输出设备

## 中央处理单元CPU（Central Processing Unit）
> 获取程序指令，对指令进行译码，并加以执行
### 组成
- 运算器
- 控制器
- 寄存器组
- 内部总线

### 中央处理单元功能
- 程序控制，控制程序的执行顺序
- 操作控制，操作信号送往对应部件，控制部件执行
- 时间控制，对操作进行时间控制
- 数据处理，对数据进行算术运算和逻辑运算，对数据进行加工

### 运算器组成(常考)ADAP
- 算数逻辑单元ALU（Airthmetic and Logit Unit），实现数据的算术和逻辑运算
- 数据缓冲器寄存器DR（Data Register）, 暂时存放由内存储器读出的一条指令或一个数据字
- 累加寄存器AC（Accumulate），运算结果或源操作数的存放区
- 状态条件寄存器PSW（Program Status Word），保存指令运行结果的条件码内容，如溢出标志等组成

### 运算器功能
- 执行所有算术运算，加减乘除等
- 执行逻辑运算，与或非比较

### 控制器（CPU中最重要的）IIAP
#### 组成
- 指令寄存器IR（Instruction Register），用于存储当前正在执行的指令。当计算机执行程序时，它会从内存中读取指令，并将这些指令存储在指令寄存器中。
- 指令译码器ID（Instruction Decoder），分析指令操作码
- 地址寄存器AR（Address Register），AR通常用于存储将要读取或写入的内存单元的地址。当CPU执行指令时，它需要知道数据或指令的存储位置，这时就会使用AR来存储这个地址。
- 程序计数器PC（program counter），用于存储当前正在执行的指令的地址或者下一条将要执行的指令的地址。它是指令执行过程中的重要组成部分，指示了CPU当前所处的程序执行位置。

#### 功能
- 控制整个CPU的工作，程序控制，时序控制

## 数据的进制转化
### 进制转化
- 2进制，0b110，0b开头
- 8进制，0771，0开头
- 10进制，10
- 16进制，0xFF，18FH，0x开头或者H结尾

### R进制转10进制
求和（系数*16^(n-1) + ... + 系数*16^0）

### 10进制转R进制
十进制除以R倒取余数，若不为0，则继续用商除以R取余数，直到余数为0

### m进制转n进制
通过十进制中转一下

### 二进制转八进制可以直接转化
三位二进制，代表一个八进制。如果不足3位，则在前面补0

### 二进制转十六进制可以直接转化
四位二进制，代表一个十六进制

## 数据展示
### 机器数
- 二进制计数，小数点隐含，不占据位置
- 分为有符号和无符号，有符号的首位用0/1分别代表正/负。无符号则全是正数

### 定点表示法
- 纯小数，小数点在最高位后
- 纯整数，小数点在最低位后

### 真值
- 把机器数转为实际数字，比如十进制数

### 四种码
- 原码，正常二进制表示，0有+0和-0两种。1000000和0000000
  + 有符号的范围，-(2^n-1 - 1) ~ (2^n-1 - 1)，减1是为了减0
- 反码，0两种种表现形式
  + 正数的反码就是原码
  + 负数的反码，符号位除外全部取反
  + 有符号的范围，-(2^n-1 - 1) ~ (2^n-1 - 1)
- 补码，0只有一种表现形式
  + 正数的补码就是原码
  + 负数的反码，符号位除外全部取反，最后+1
  + 有符号的范围，-(2^n-1) ~ (2^n-1 - 1)
- 移码
  + 无论正负，都是把符号位取反
  + 有符号的范围，-(2^n-1) ~ (2^n-1 - 1)

### 45的原码，反码，补码，移码
- 原码：00101101
- 反码：00101101
- 补码：00101101
- 移码：10101101

### -45的原码，反码，补码
- 原码：10101101
- 反码：11010010
- 补码：11010011
- 移码：00101101

## 浮点数，类似科学计数法
- 尾数只能是小数，必须规格化
- 阶码必须是整数
- 2^E次方，则是二进制往左移动E个位置
N = F * 2^E , F是尾数（纯小数），E是阶数（纯整数），0.10111 * 2^3
> 数值范围由阶码确定，数值精度由尾数确定
- 组成：阶符，阶码，数符，尾数

### 尾数原码的表示法，即有效位的最高位必须为1
> 负数尾数，1.1xxxx
> 正数尾数，0.1xxxx

### 尾数补码的表示法，即符号位和有效位最高位必须不同
> 负数尾数，1.0xxxx
> 正数尾数，0.1xxxx

### 浮点数运算
- 对阶，是两个数阶码相同，小阶向大阶看齐。小阶码变大几位，则尾数右移几位
- 尾数计算，如果是减法，就加负数
- 结果规格化

### 逻辑运算
- &运算，都是1才为1
- |运算，都是0才为0
- ^运算，相同为0，不同为1
- ！运算，直接取反
- 左移，左移N位，高为溢出则舍去，低位补0
- 右移，右移N位，低位溢出则舍去，高位补0

### 校验码
> 主要用来对编码进行检错和纠错
- 码距，从A码转变到B码之间，需要改变的位数，单个编码的码距为1，因为只需要改变一位，码距越大，越利于纠错和检错

### 奇偶校验（只能检1位错，无法纠错）
- 在最后插入一个奇数或偶数位
- 奇偶校验码，在编码中增加1位校验码来使编码中1的个数为奇数（奇校验）或者偶数（偶校验），从而使码距变成2【只能检1位错，无法纠错】
- 奇校验，接收方收到编码后，判断编码里面1的个数是不是奇数，如果是就没问题，否则就有问题
- 偶校验，和奇校验相反

#### 循环冗余检验码（CRC）Cylic Redundancy Check（可以检多位错，无法纠错）
- 题目一般给出多项式，要把多项式变为二进制编码，得到二进制编码的长度
- 给原始报文后面加上长度-1个0
- 进行除法运算。是模2运算，也就是异或运算，同0非1，不需要借位
- 除完后得到余数，如果余数不够长度-1，则在前面补0
- 把原始报文+余数，发送给接收方
- 接收方知道多项式，用接收到的数据除多项式，看看能否整除，整除则没问题

格式：数据位 + 校验码
- 原始报文,11001010101 不能直接参与运算，要在后面补上多项式的位数-1个0，现在是11001010101 0000，被除数
- 生成的多项式，x^4 + X^3 + x + 1 ==》 11011，除数，模二运算，一直上1。就是0-1等于1，但是不会向前借位
- 求CRC编码后结果，最后的余数就是结果，然后数据就是 11001010101  0011
- 接收方用 11001010101  0011 除以 多项式 11011，可以整除，就说明正确


#### 海明校验码（可以纠错和检错）（重点是公式：2^k - 1 >= n+k）
- 校验位在2的n次方插入
- 画格子，从1开始数数，1，2，4，8，16...2^n次方是校验位，其余放入真实数据位
> 本质也是利用奇偶性来检错和纠错，在数据位之间插入k个校验位，校验位在2的n次方插入。从1开始
重点： n是数据位，校验位是k，则2^k - 1 >= n+k。是插如原数据里面，形成编码。比如1011 --》 101r1rr
> 校验位的计算，信息位的位置拆分位校验位的位置相加，7 = 4 + 2 + 1，第四位校验码就等于拆分出来有4的的信息位异或值

#### 计算步骤
- 画出格子，从1...N
- 由题干得出信息码长度N
- 根据公式2^K >= N+K+1，算出K
- 把信息位填入格子里面，信息的的位置号分解为校验码的位置加法，比如7=4+1+2，7是一个信息位的号，4，1，2是校验位的号。最后4校验位的值等于分解中包含4的所有信息位的异或结果。展开是二进制的10进制结果，1，2，4，8

#### 检错纠错原理（了解既可）
- 根据规则，直到信息码和校验码是什么
- 进行三组异或运算
- 偶校验：结果全为0
- 奇校验：结果全为1
- 纠错：比如是偶校验，找到是1的，然后分开100，说明是第四位，直接取反就可以了


## 计算机体系结构分类
### Flynn分类法
- 单指令单数据流，SISD，单处理器系统，都是一个
- 单指令多数据流，SIMD，一个控制部分，其他都是多个，并行处理机，阵列处理机，超级向量处理机
- 多指令单数据流，MISD，被称为不可能的，（流水式计算机）
- 多指令多数据流，MIMD，全是多个，多核计算机


### 计算机指令
> 一条指令由操作码和操作数两部分组成，操作码是要完成的操作，操作数是数据和地址
- 指令是以二进制编码存放在存储器中
- 执行过程：取指令-分析指令-执行指令。首先在PC（程序计数器）中取出指令地址，送入地址总线，CPU根据地址取出指令内容，存入IR，指令译码器ID进行分析指令操作，最后执行指令，取出源操作数

### 指令寻址方式（指令执行顺序）
- 顺序寻址：一条接一条
- 跳跃寻址：下一条指令不由PC给出，由本条指令给出。所以PC内容也要动态改变，及时更新新的地址。比如JUMP指令

### 指令操作数的寻址方式（操作数怎么找）
- 立即寻址：指令直接记录的就是操作数
- 直接寻址：指令记录的是操作数在主存的地址
- 间接寻址：指令记录的是操作数的地址
- 寄存器寻址：记录的是寄存器的编号
- 其他寻址

### 指令系统（重点）
- CISC（Complex Instruction Set Computing）
  + 指令数量多，使用频率差别大，可变长格式，多种寻址方式，（微程序控制技术），研制周期长
- RISC（Reduced Instruction Set Computing）
  + 数量少，使用频率接近，定长格式，单周期指令，寻址方式少，（增加大量寄存器，硬布线逻辑，适合采用流水线），优化编译，支持高级语言

### 指令流水线
- 取指，分析，执行
- 不用流水线的话，3条指令需要3*3=9T
- 采用流水线，3条指令需要3+2=5T

### 流水线计算，公式重要
- 流水线周期，时间最长的段就是周期
- 执行时间 = 一条流水线总时间 + （总指令条数 - 1） * 流水线周期
- 流水线吞吐率 = 条数 / 时间
- 加速比 = 不使用流水线时间 / 使用流水线时间

### 超标量计算
- 常规流水线，度是1
- 需要把指令条数换算 = 指令条数 / 度
- 其他都一样

## 存储系统
### 层次结构
- CPU内部寄存器
- Cache，是内存部分内容的拷贝，最活跃的内容。速度是内存的5~10倍。对程序员说是透明的
- 主存储器，内存
- 联机磁盘
- 脱机磁盘

### 两级存储。原理就是依据局部性原理
- Cache到主存
- 主存到辅存

### 局部性原理
- 时间局部性原理。比如循环结构的i
  + 相邻的时间内会访问同一个数据项
- 空间局部性原理。比如数据结构中数组
  + 相邻的空间地址会被连续访问

### 地址映射
- 把主存地址转换为Cache地址，因为CPU送出的是主存地址。这个映射有硬件自动完成映射

#### 直接映射
- 若内存容量为1GB,Cache容量为8MB,页面的大小为512KB。直接映像中,先分区,再分页。一个区的大小就是Cache容量的大小,所以一共分:1GB/8MB=128个区，区号7位。每个区分:8MB/512KB=16个页，所以页号为4位。
- 在直接映像方式中，每个主存页只能复制到某一固定的Cache页中。直接映像方式的映像规律是:主存中每个区的第0页,只能进入到Cache的第0页。即:若当前时刻Cache中0号页已被占据，而1-15号页空闲，现在要将1区第0页(即内存的16页)调入Cache是会发生冲突的。
- 在Cache中，为每一个页设立一个Cache标记，该标记用于识别当前的Cache块来自于哪个内存页
- 有点：容易实现，简单
- 缺点：容易产生冲突，不灵活，利用率不高
#### 全相联映射
- 也是分块，主存每一块都能放到Cache中的块中，只有Cache满了才会冲突
- 缺点：复杂，速度慢
- 优点：资源利用高，冲突低
#### 组相联映射
- Cahce先分块，再分组。主存也是。前面两种的结合。
- 组间采用直接映射
- 组内是全相联映射

### Cache命中率
- 当CPU访问的数据在Cache中，称为命中。否则称谓未命中，从主存中取。
- 根据命中率求时间。比如Cache命中率80%，Cache读写时间是10ns，主存读写是100ns，则时间=（80%*10 + 20%*100）
- 这是指令的时间，还有操作数的时间同理

### 主存编址
- K和k不同，K是1024，k是1000
- B和b不同，B是字节，b是位，byte，1B = 8b
- 内存单元个数 = 末地址 - 首地址 + 1
- 内存容量 = 内存单元个数 * 每个单元的大小（按字节编址就是1个单元1字节，双字节就是一个单元2个字节） 
- 芯片片数 = 容量 / 每片容量 

### 总线结构
> 广义上说，任何连接两个以上元器件的导线都可以称之为总线
- 内部总线：内部芯片级别的总线，芯片与处理器通信的总线
- 系统总线：板级总线，计算机各部分连接，ISA，EISA总线，PCI总线 
  + 数据总线，并行传输数据位数（8位）
  + 地址总线，系统可管理内存空间大小（地址是32位，则内存最多是2^32次方）
  + 控制总线，传输控制命令
- 外部总线：设备一级的总线，RS232串行总线，SCSI并行总线，USB通用串行总线
- 串行总线：一条线，适合长距离，但是低速
- 并行总线：多条，短距离，高速
- 半双工总线：同一时刻只能在一个方向传输数据，还是双方可以通信

### 系统可靠性分析
- 平均无故障时间：MTTF = 1 / 失效率
- 平均故障修复时间：MTTR = 1 / 修复率
- 平均故障间隔时间：MTBF = MTTF + MTTR
- 系统可用性：MTTF / MTBF

### 题型
- 系统可靠度计算R1*R2*(1-R3)