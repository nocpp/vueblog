(window.webpackJsonp=window.webpackJsonp||[]).push([[91],{545:function(v,_,l){"use strict";l.r(_);var t=l(2),o=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"algorithm"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#algorithm"}},[v._v("#")]),v._v(" algorithm")]),v._v(" "),_("h3",{attrs:{id:"排序算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#排序算法"}},[v._v("#")]),v._v(" 排序算法")]),v._v(" "),_("ul",[_("li",[v._v("直接插入排序【插入排序】")])]),v._v(" "),_("blockquote",[_("p",[v._v("假设有一列已经排好序的数据，然后把待排序的插入其中，使得其再次有序，再往复")])]),v._v(" "),_("ul",[_("li",[v._v("希尔排序【插入排序】")])]),v._v(" "),_("blockquote",[_("p",[v._v("直接插入排序的升级版，先把待排序列分为若干子序列，然后分别插入排序，适用于大数据的排序，分组的方法，提高效率。每隔多少增量进行排序")])]),v._v(" "),_("ul",[_("li",[v._v("简单选择排序【选择排序】")])]),v._v(" "),_("blockquote",[_("p",[v._v("每次选出最小的，和第一个交换")])]),v._v(" "),_("ul",[_("li",[v._v("堆排序，也是选择排序的一种，适用于多个元素中找出前几名【选择排序】")])]),v._v(" "),_("blockquote",[_("p",[v._v("堆，根结点要么都大于孩子，大顶堆，要么都小于孩子，小顶堆。排序要建堆，完全二叉树\n+ 根据序列，建立完全二叉树\n+ 找到最后一个非叶节点，和孩子比较，进行交换，建堆\n+ 不断往上比较，交换之后，要注意是否影响子节点\n+ 直到根结点，就建立了初始堆\n+ 然后取走堆顶元素，再把堆中最后一个元素放入堆顶，再按上面步骤建立初始堆，再取走堆顶元素\n+ 直到最后一个元素，就完成了排序")])]),v._v(" "),_("ul",[_("li",[v._v("冒泡排序【交换排序】")])]),v._v(" "),_("blockquote",[_("p",[v._v("两两比较，较小的元素放到前面")])]),v._v(" "),_("ul",[_("li",[v._v("快速排序【交换排序】")])]),v._v(" "),_("blockquote",[_("p",[v._v("递归思想，选个基准值，从i，j开始比较，第一趟，基准值值左边都比他小，右边都比它大。都是和基准值进行比较，每次交换后换另一个指针")])]),v._v(" "),_("ul",[_("li",[v._v("归并排序，一般是用来合并多个线性表的")])]),v._v(" "),_("blockquote",[_("p",[v._v("把两个有序文件，合并为一个新的有序文件 ，两路或者三路")])]),v._v(" "),_("ul",[_("li",[v._v("基数排序")])]),v._v(" "),_("blockquote",[_("p",[v._v("借助多关键字排序，通过个位，十位，排序等")])]),v._v(" "),_("h3",{attrs:{id:"算法的方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#算法的方法"}},[v._v("#")]),v._v(" 算法的方法")]),v._v(" "),_("ul",[_("li",[v._v("分治法，二分查找，归并等，递归。划分的子问题都是相同的")])]),v._v(" "),_("blockquote",[_("p",[v._v("复杂问题，分解为简单子问题，然后合并为问题的解")])]),v._v(" "),_("ul",[_("li",[v._v("回溯法，通用解题法，解决迷宫类问题。深度优先")])]),v._v(" "),_("blockquote",[_("p",[v._v("一直向下搜索，解决不通再返回上一层")])]),v._v(" "),_("ul",[_("li",[v._v("动态规划法，每一步都是最优，划分为一个个子问题，不一定相同")])]),v._v(" "),_("blockquote",[_("p",[v._v("在前期构造出表格，每一步最优，全局最优")])]),v._v(" "),_("ul",[_("li",[v._v("贪心法，总是从当前来说是局部最优，但是不是整体最优，局部最优")])]),v._v(" "),_("blockquote",[_("p",[v._v("一般可以快速得到解，而不是最优解")])]),v._v(" "),_("ul",[_("li",[v._v("分支限界法")])]),v._v(" "),_("blockquote",[_("p",[v._v("与回溯法类似，在问题的解空间树上，搜索问题解的方法\n区别: 找出满足约束条件的解，某种意义上的最优解，不是要求所有解，而且是广度优先")])]),v._v(" "),_("ul",[_("li",[v._v("概率算法")])]),v._v(" "),_("blockquote",[_("p",[v._v("算法在执行某些步骤时，可以随机选择下一步，并允许结果以较小概率出现错误。降低算法执行时间和复杂度")])]),v._v(" "),_("ul",[_("li",[_("p",[v._v("近似算法")])]),v._v(" "),_("li",[_("p",[v._v("数据挖掘算法，核心是算法")])])]),v._v(" "),_("ul",[_("li",[v._v("分类，对数据进行分类，根据历史数据预测，步骤：学习模型，应用模型。\n找出频繁模式和分析关联规则挖掘，沃尔玛尿布和啤酒的故事\n分类有监督的学习过程，聚类无监督")]),v._v(" "),_("li",[v._v("回归")]),v._v(" "),_("li",[v._v("关联规则")]),v._v(" "),_("li",[v._v("聚类")])]),v._v(" "),_("ul",[_("li",[v._v("智能优化算法\n"),_("ul",[_("li",[v._v("以数学为基础，用于求解工程最优解")]),v._v(" "),_("li",[v._v("人工神经网络ANN（模拟人的思考），遗传算法，模拟退火算法SA")]),v._v(" "),_("li",[v._v("人工神经网络，机器学习--》深度学习，让机器学习")])])])])])}),[],!1,null,null,null);_.default=o.exports}}]);